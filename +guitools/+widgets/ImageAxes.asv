classdef ImageAxes < matlab.ui.componentcontainer.ComponentContainer
% widgets.ImageAxes - Image viewer with custom tool hosting and figure-level event routing via FigureEventHub
%
%
%
%   Notes:
%
%   Make sure CData argument comes before CLim when calling the constructor
%
%   If you use multiple instances of ImageAxes in the same figure window, 
%   make sure the Name property of each is unique
%
%



    %% Tool Management

    properties (SetAccess=?widgets.ImageAxesTool)
        % struct() of installed tools, fieldnames match tool Name
        Tools struct = struct()
    end

    properties (Dependent)
        % the set of tools to INSTALL (tools which are listed in the toolbar)
        ToolBelt
        % the set of tools to LOAD (tools which are available for install)
        ToolBox
    end

    properties (Access=private)
        % registry of loaded tools
        ToolList        % containers.Map name->tool
        % registry of installed tools
        ToolRegistry    % containers.Map name->tool
    end

    properties (Access=?widgets.ImageAxesTool)
        % the currently enabled tool with IsExclusive=true (if it exists)
        ActiveExclusiveTool
        % struct() of ToolbarButtons, fieldnames match tool Name
        ToolbarButtons struct = struct()
    end

    %% Public Parameters
    properties (AbortSet)
        Name (1,1) string = ""
    end

    % Passthroughs
    properties (Dependent)
        ImageVisible
        AxesVisible
        ColorbarVisible
        Colormap (256,3) double
        MaxRenderedResolution
    end

    %% CData management

    % Public properties (some with private backing)
    properties (Dependent, AbortSet)
        CLim                (1,2) double
        CanMerge            (1,1) logical

        CData               (:,:,:) {mustBeA(CData,{'double','single','uint8','uint16','logical','cell'})}
        CLimMode            (1,:) char
        ChannelIdx          (1,1) double
        ShowComposite       (1,1) matlab.lang.OnOffSwitchState
        ChannelColors       (1,:) cell {mustBeMember(ChannelColors,{'cyan','magenta','yellow','red','green','blue'})} = {}
        ChannelColormaps    (1,:) cell
        ChannelColorMode    (1,:) char {mustBeMember(ChannelColorMode,{'colors','luts'})}
    end

    properties (Access=private)
        CData_              (:,:,:) = widgets.ImageAxes.placeholderImage;
        CLimMode_           (1,:) char {mustBeMember(CLimMode_,{'auto','manual'})} = 'auto'
        ChannelIdx_         (1,1) double = 1
        ShowComposite_      (1,1) matlab.lang.OnOffSwitchState = 'off'
        ChannelColors_      (1,:) cell {mustBeMember(ChannelColors_,{'cyan','magenta','yellow','red','green','blue'})} = {}
        ChannelColormaps_   (1,:) cell = {}
        ChannelColorMode_   (1,:) char {mustBeMember(ChannelColorMode_,{'colors','luts'})} = 'colors'
    end

    % read-only
    properties (Dependent, SetAccess=private)
        DisplayCData
        CDataType       (1,:) char {mustBeMember(CDataType,{'grayscale','rgb'})}
        CDataSize       (1,:) double
        CDataClass      (1,:) char {mustBeMember(CDataClass,{'double','single','uint8','uint16','logical',''})}
    end

    properties (SetAccess=private)
        nChannels           (1,1) double = 1
        MultiChannel        (1,1) matlab.lang.OnOffSwitchState = 'off'
        MultiChannelType    (1,:) {mustBeMember(MultiChannelType,{'grayscale','rgb','mixed','none'})} = 'none'
    end

    % CData prop stores
    properties (Access=private)
        CDataStore      (1,:) cell = {}
        CLimStore       (1,:) cell = {}
        CDataClassStore (1,:) cell = {}
        CDataSizeStore  (1,:) cell = {}
        CDataTypeStore  (1,:) cell = {}
        CDataMapStore   (1,:) cell = {}
    end

    %% UI/Graphics

    % private
    properties (Access=private, Transient, NonCopyable)
        Grid matlab.ui.container.GridLayout
        Panel matlab.ui.container.Panel
        staticAxes matlab.ui.control.UIAxes
        hImage matlab.graphics.primitive.Image
        L event.listener
        TopLabel (1,1) matlab.graphics.primitive.Text
        BottomLabel (1,1) matlab.graphics.primitive.Text
        Colorbar matlab.graphics.illustration.ColorBar
    end

    % tool-accessible
    properties (Access=?widgets.ImageAxesTool)
        mainAxes matlab.ui.control.UIAxes
    end

    %% Derived properties (accessible to tools)
    properties (Access=?widgets.ImageAxesTool, Dependent)
        ParentFig

        ImageSize
        ImageWidth
        ImageHeight

        defaultXLim
        defaultYLim
        cursorPosition
        cursorPositionStatic
        activePixel
    end

    %% Tool helper variables
    properties (Access=?widgets.ImageAxesTool)
        % control XLim and YLim of axes holding the image (if empty, lims will be set to default)
        XLim = []
        YLim = []
    end

    %% Modes for routing
    properties (SetAccess=private)
        Mode struct = struct()
    end

    %% Hub registration
    properties (Access=private)
        Hub app.FigureEventHub
        RouterId double = NaN
    end

    %% Events
    events (NotifyAccess=protected)
        CDataChanged
    end

    %% ComponentContainer lifecycle (setup/update)
    methods (Access=protected)

        function setup(obj)

            obj.Interruptible = 'off';
            obj.BusyAction = 'cancel';

            % Main grid
            obj.Grid = uigridlayout(obj,[1,1], ...
                'RowHeight',{'1x'},...
                'ColumnWidth',{'1x'},...
                'RowSpacing',0,...
                'ColumnSpacing',0,...
                'Padding',[0 0 0 0], ...
                'BackgroundColor',[1 1 1]);

            % Panel to hold the axes
            obj.Panel = uipanel(obj.Grid, ...
                'BackgroundColor',[0 0 0],...
                'AutoResizeChildren','off',...
                'BorderWidth',0);

            % Main axes
            obj.mainAxes = uiaxes(obj.Panel, ...
                'Units','normalized', ...
                'InnerPosition',[0 0 1 1], ...
                'YDir','reverse', ...
                'YLim',obj.defaultYLim, ...
                'XLim',obj.defaultXLim, ...
                'XTick',[], ...
                'YTick',[], ...
                'Color',[0 0 1], ...
                'XColor','none', ...
                'YColor','none', ...
                'Visible','off', ...
                'PositionConstraint','innerposition', ...
                'NextPlot','add', ...
                'HitTest','on', ...
                'PickableParts','all');
            obj.mainAxes.Toolbar = axtoolbar(obj.mainAxes,{});
            obj.mainAxes.Interactions = [];
            disableDefaultInteractivity(obj.mainAxes);


            % Static axes (used for cursor-follow zoom math)
            obj.staticAxes = uiaxes(obj.Panel, ...
                'Units','normalized', ...
                'InnerPosition',[0 0 1 1], ...
                'YDir','reverse', ...
                'YLim',obj.defaultYLim, ...
                'XLim',obj.defaultXLim, ...
                'XTick',[], ...
                'YTick',[], ...
                'Color',[0 0 1], ...
                'XColor','none', ...
                'YColor','none', ...
                'Visible','off', ...
                'PositionConstraint','innerposition', ...
                'HitTest','off', ...
                'PickableParts','none');
            obj.staticAxes.Toolbar = axtoolbar(obj.staticAxes,{});
            obj.staticAxes.Interactions = [];
            disableDefaultInteractivity(obj.staticAxes);
            obj.staticAxes.PlotBoxAspectRatio = [1 1 1];
            obj.staticAxes.DataAspectRatio = [1 1 1];

            % setup and store colorbar
            obj.Colorbar = colorbar(obj.mainAxes,"east","Visible","off");

            % initialize registries for loaded and installed tools
            obj.ToolList = containers.Map('KeyType','char','ValueType','any');
            obj.ToolRegistry = containers.Map('KeyType','char','ValueType','any');

            % load all tools in obj.ToolBox
            obj.loadTools(obj.ToolBox);
            % install all tools in obj.ToolBelt
            obj.installTools(obj.ToolBelt);

            % Hub registration (one hub per figure; this instance registers itself)
            obj.Hub = app.FigureEventHub.ensure(obj.ParentFig);
            obj.RouterId = obj.Hub.register(obj,'Priority',10,'CaptureDuringDrag',true);

            % Image
            obj.hImage = image(obj.mainAxes,[],...
                'CDataMapping','scaled',...
                'HitTest','off',...
                'PickableParts','none');

            % Update CLim, PlotBoxAspectRatio, and DataAspectRatio *after* creating image object
            obj.mainAxes.CLim               = [0 1];
            obj.mainAxes.PlotBoxAspectRatio = [1 1 1];
            obj.mainAxes.DataAspectRatio    = [1 1 1];

            % set SizeChangedFcn so we can force visual update upon resizing (AutoResizeChildren of parent must be Off)
            obj.SizeChangedFcn = @(~,~) obj.updateOnResize();

            % label in bottom-left corner
            obj.BottomLabel = text('Parent',obj.staticAxes,...
                'Units','normalized',...
                'Position',[0.005 0.005],...
                'Color',[1 1 1],...
                'BackgroundColor',[0 0 0 0.5],...
                'String','',...
                'Clipping','on',...
                'Margin',3,...
                'HorizontalAlignment','left',...
                'VerticalAlignment','bottom');

            % label in top-left corner
            obj.TopLabel = text('Parent',obj.staticAxes,...
                'Units','normalized',...
                'Position',[0.005 0.995],...
                'Color',[1 1 1],...
                'BackgroundColor',[0 0 0 0.5],...
                'String','',...
                'Clipping','on',...
                'Margin',3,...
                'HorizontalAlignment','left',...
                'VerticalAlignment','top');


            % set default colormap
            obj.Colormap = gray;

            % update CData prop stores
            obj.setChannels(obj.CData_);

            % initial UI sync
            obj.refreshView();

        end

        function update(obj)
            % set the Tag property of the mainAxes
            obj.mainAxes.Tag = obj.Name;

            % set BackgroundColor
            obj.Grid.BackgroundColor = obj.BackgroundColor;
            obj.Panel.BackgroundColor = obj.BackgroundColor;
        end

    end

    %% Internal update helpers
    methods (Access=private)

        function updateOnResize(obj)
            if ~isvalid(obj); return; end
            drawnow;  % keep label positioning accurate during live resizes
            obj.update();
        end

        function updateBottomLabelText(obj)

            px = obj.activePixel;

            if isempty(px), obj.BottomLabel.String ='Hover over image to interact'; return; end

            % posStr = sprintf(' (X, Y)=(%0.f, %0.f)',px(1),px(2));
            posStr = sprintf('Pixel: (%0.f,%0.f)',px(1),px(2));

            switch obj.CDataType
                case 'grayscale'
                    switch obj.CDataClass
                        case {'double','single'}
                            valStr = sprintf('Intensity: %0.2f',obj.CData(px(2),px(1)));
                        case {'uint8','uint16'}
                            valStr = sprintf('Intensity: %i',obj.CData(px(2),px(1)));
                        case 'logical'
                            valStr = sprintf('Value: %i',obj.CData(px(2),px(1)));
                    end
                case 'rgb'
                    switch obj.CDataClass
                        case {'double','single'}
                            valStr = sprintf('RGB: [%0.2f, %0.2f, %0.2f]',obj.CData(px(2),px(1),1:3));
                        case {'uint8'}
                            valStr = sprintf('RGB: [%i, %i, %i]',obj.CData(px(2),px(1),1:3));
                    end
            end

            % get cell array of installed tools, sorted by priority
            tools = obj.prioritySortTools(obj.ToolRegistry);

            % preallocate cell of info label char vectors
            txt = cell(1,numel(tools));


            for i = 1:numel(tools)
                % get info label for each tool
                txt{i} = tools{i}.getLabelString();
            end

            txt = [posStr,valStr,txt];

            % remove empty entries
            txt(ismember(txt,'')) = [];

            % join each fragment with spaced pipe
            txt = strjoin(txt,' | ');

            obj.BottomLabel.String = [' ',txt];
        end

        function updateTopLabelText(obj)

            infoStr = obj.getImageInfoString();
            channelStr = obj.getChannelInfoStr();

            txt = {infoStr,channelStr};

            % join each fragment with spaced pipe
            txt = strjoin(txt,' | ');

            obj.TopLabel.String = [' ',txt];
        end

        function updatePointer(obj)

            % invalid pixel, set pointer to 'arrow'
            if isempty(obj.activePixel), obj.ParentFig.Pointer = 'arrow'; return; end

            % get cell array of installed tools, sorted by priority
            tools = obj.prioritySortTools(obj.ToolRegistry);

            % no tools found, set pointer to 'arrow'
            if isempty(tools), obj.ParentFig.Pointer = 'arrow'; return; end

            for i = 1:numel(tools)
                pointer = tools{i}.getPreferredPointer();

                if isempty(pointer)
                    continue
                end

                switch pointer
                    case 'default'
                        % do nothing (let the pointer be set normally)
                        return
                    otherwise
                        % a valid pointer is returned, set it and return
                        obj.ParentFig.Pointer = pointer;
                        return
                end

            end

            % no valid pointer was returned, set pointer to 'arrow'
            obj.ParentFig.Pointer = 'arrow';

        end

        function updateImageCData(obj)
            obj.hImage.CData = obj.DisplayCData;
        end

        function updateColorbar(obj)
            clim = obj.CLim;

            ticks = {};
            labels = {};

            switch obj.CDataType
                case 'grayscale'
                    [ticks,labels] = widgets.ImageAxes.getColorbarTickLabels(obj.CDataClass,clim);
                case 'rgb'
                    if obj.ShowComposite
                        [ticks,labels] = widgets.ImageAxes.getColorbarTickLabels(obj.CDataClassStore{obj.ChannelIdx},clim);
                    end
            end

            obj.Colorbar.Ticks = ticks;
            obj.Colorbar.TickLabels = labels;
        end

        function updateAxesColormap(obj)
            obj.mainAxes.Colormap = obj.CDataMapStore{obj.ChannelIdx};
        end

        function refreshView(obj)
            % update the CData of the Image
            obj.updateImageCData();
            % update the Colormap of the Axes
            obj.updateAxesColormap();
            % update the Colorbar
            obj.updateColorbar();
            % update axes limits
            obj.restoreDefaultLimits();
            % update image info label
            obj.updateTopLabelText();
        end

    end

    %% Internal display helpers
    methods (Access=private)

        function s = getImageInfoString(obj)

            s1 = sprintf(strjoin(repmat({'%i'},1,numel(obj.CDataSize)),'x'),obj.CDataSize);
            s2 = sprintf('%s (%s)',obj.CDataClass,obj.CDataType);

            s = [s1,' ',s2];
        end

        function s = getChannelInfoStr(obj)
            switch obj.ShowComposite
                case 'on'
                    s = sprintf('Channel: %i/%i (composite)',obj.ChannelIdx,obj.nChannels);
                case 'off'
                    s = sprintf('Channel: %i/%i',obj.ChannelIdx,obj.nChannels);
            end

        end

    end

    %% Tool-accessible helpers
    methods (Access=?widgets.ImageAxesTool, Hidden=true)
        
        function setMode(obj, modeName, modeState)
            % if mode does not exist
            if ~isfield(obj.Mode,modeName)
                % warn and return
                warning('Could not set mode state. "%s" mode does not exist.',modeName)
                return
            end
            % set the mode state
            obj.Mode.(modeName) = logical(modeState);
        end

        function addMode(obj, modeName)
            % if mode already exists
            if isfield(obj.Mode,modeName)
                % warn and return
                warning('Could not add mode. "%s" mode already exists',modeName)
                return
            end
            % add the mode (false by default)
            obj.Mode.(modeName) = false;
        end

        function removeMode(obj, modeName)
            % if mode does not exist
            if ~isfield(obj.Mode,modeName)
                % warn and return
                warning('Could not remove mode. "%s" mode does not exist.',modeName)
                return
            end
            % remove the mode
            obj.Mode = rmfield(obj.Mode,modeName);
        end

        function updateFromTool(obj)
            obj.updateBottomLabelText();
            obj.updatePointer();
        end

        function restoreDefaultLimits(obj)
            obj.staticAxes.XLim = obj.defaultXLim;  
            obj.staticAxes.YLim = obj.defaultYLim;
            obj.mainAxes.XLim = obj.defaultXLim;  
            obj.mainAxes.YLim = obj.defaultYLim;
        end

    end

    %% Derived getters and setters
    methods

        % cursor position in axes/image
        function cursorPosition = get.cursorPosition(obj)
            cursorPosition = obj.mainAxes.CurrentPoint(1,[1,2]);
            % return empty if outside limits
            if ~obj.isInLimits(cursorPosition,obj.mainAxes.XLim,obj.mainAxes.YLim)
                cursorPosition = [];
            end
        end

        function cursorPositionStatic = get.cursorPositionStatic(obj)
            cursorPositionStatic = obj.staticAxes.CurrentPoint(1,[1,2]);
            % return empty if outside limits
            if ~obj.isInLimits(cursorPositionStatic,obj.staticAxes.XLim,obj.staticAxes.YLim)
                cursorPositionStatic = [];
            end
        end

        function px = get.activePixel(obj)
            % cursor position in axes
            XY = obj.cursorPosition;
            % empty -> return
            if isempty(XY), px = []; return, end
            % round to integer px indices, clip to image dimensions
            px = [clip(round(XY(1)),1,obj.ImageWidth), clip(round(XY(2)),1,obj.ImageHeight)];
        end

        % image dimensions
        % function s = get.ImageSize(obj),    s = size(obj.CData); end
        % function h = get.ImageHeight(obj),  h = size(obj.CData,1); end
        % function w = get.ImageWidth(obj),   w = size(obj.CData,2); end

        function s = get.ImageSize(obj),    s = obj.CDataSize;      end
        function h = get.ImageHeight(obj) 
            h = obj.ImageSize(1);   
        end
        function w = get.ImageWidth(obj)
            w = obj.ImageSize(2);
        end


        
        % default axes limits (set to prefectly enclose image)
        function x = get.defaultXLim(obj),  x = [0 obj.ImageWidth] + 0.5; end
        function y = get.defaultYLim(obj),  y = [0 obj.ImageHeight] + 0.5; end

        % retrieve fig/axes handles
        function f = get.ParentFig(obj),    f = ancestor(obj,'Figure'); end
        function ax = getAxes(obj), ax = obj.mainAxes; end
        function ax = getOverlayAxes(obj), ax = obj.staticAxes; end

        % axes/image passthroughs (Set/Get)

        % ImageVisible
        function v = get.ImageVisible(obj),v = obj.hImage.Visible; end
        function set.ImageVisible(obj,val),obj.hImage.Visible = val; end
        % AxesVisible
        function v = get.AxesVisible(obj), v = obj.mainAxes.Visible; end
        function set.AxesVisible(obj,val), obj.mainAxes.Visible = val; end
        % ColorbarVisible
        function v = get.ColorbarVisible(obj), v = obj.Colorbar.Visible; end
        function set.ColorbarVisible(obj,val), obj.Colorbar.Visible = val; end
        % MaxRenderedResolution
        function v = get.MaxRenderedResolution(obj), v = obj.hImage.MaxRenderedResolution; end
        function set.MaxRenderedResolution(obj,val), obj.hImage.MaxRenderedResolution = val; end


    end

    %% Hub-facing event handlers (matches | onDown | onMove | onUp | onScroll | onKeyPress | onEnter | onLeave)
    methods

        % determine whether this instance should claim event from FigureEventHub
        function tf = matches(obj, tgt, kind, ~)
            % tf = matches(obj, tgt, kind, evt)
            % obj: this component
            % tgt: hittest result from FigureEventHub that we are checking for a match to this component
            % kind: the specific kind of mouse event (i.e. 'move', 'down', 'up', 'scroll', or 'key')
            % evt: event data associated with the event

            % get the ancestor axes of tgt
            ancestorAx = ancestor(tgt,'matlab.ui.control.UIAxes');
            % empty -> return false
            if isempty(ancestorAx), tf = false; return, end

            % axes Tag does not match Name of this ImageAxes -> return false
            if ~strcmp(ancestorAx.Tag,obj.Name), tf = false; return, end

            % event hit the toolbar
            if ~isempty(ancestor(tgt,'matlab.ui.controls.AxesToolbar'))
                % get toolbar button under cursor (if it exists)
                btn = ancestor(tgt,'matlab.ui.controls.ToolbarStateButton');
                % button exists and event kind is 'move' -> return true (otherwise return false)

                if ~isempty(btn) && strcmp(kind,'move')
                    tf = true;
                else
                    tf = false;
                end

                return
            end

            % return true for anything else that belongs to *this* ImageAxes instance
            ia = ancestor(tgt,'widgets.ImageAxes');
            tf = (ia == obj);
        end

        function onDown(obj, evt, tgt)
            skipInterceptor = obj.routeToDistractors(evt,tgt,'Down');
            if skipInterceptor, return; end

            % get highest priority DownInterceptor
            t = obj.getPriorityInterceptor('Down');
            % if tool exists, forward this event to the tool
            if ~isempty(t), t.onDown(evt, tgt); end
        end

        function onMove(obj, evt, tgt)
            % get the ancestor toolbar button clicked, if it exists
            btn = ancestor(tgt,'matlab.ui.controls.ToolbarStateButton');
            if ~isempty(btn) % if it exists
                % set image info label to display button tooltip, return
                obj.BottomLabel.String = sprintf(' %s',btn.Tooltip); return
            end

            skipInterceptor = obj.routeToDistractors(evt,tgt,'Move');
            if skipInterceptor, return; end

            % get highest priority MoveInterceptor
            t = obj.getPriorityInterceptor('Move');
            % if tool exists, forward this event to the tool
            if ~isempty(t), t.onMove(evt, tgt); end
            % Host maintenance (update label/pointer/etc. on move if desired)
            obj.onMouseMove();
        end

        function onUp(obj, evt, tgt)
            skipInterceptor = obj.routeToDistractors(evt,tgt,'Up');
            if skipInterceptor, return; end

            % get highest priority UpInterceptor
            t = obj.getPriorityInterceptor('Up');
            % if tool exists, forward this event to the tool
            if ~isempty(t), t.onUp(evt, tgt); end
        end

        function onScroll(obj, evt, tgt)
            skipInterceptor = obj.routeToDistractors(evt,tgt,'Scroll');
            if skipInterceptor, return; end

            % get highest priority ScrollInterceptor
            t = obj.getPriorityInterceptor('Scroll');
            % if tool exists, forward this event to the tool
            if ~isempty(t), t.onScroll(evt, tgt); end
        end

        function onKeyPress(obj, evt, tgt)
            % get highest priority KeyPressInterceptor
            t = obj.getPriorityInterceptor('KeyPress');
            % if tool exists, forward this event to the tool
            if ~isempty(t), t.onKeyPress(evt, tgt); end


            fprintf('widgets.ImageAxes.onKeyPressed()\n');
            fprintf('Character: %s\n',evt.Character)
            fprintf('Key: %s\n',evt.Key)
            fprintf('Unicode: %d\n',double(evt.Character))

            n = 1;
            for m = evt.Modifier
                fprintf('Modifier %i: %s\n',n,m{1});
                n = n+1;
            end

            switch evt.Key
                case 'rightarrow'
                    obj.nextChannel();
                case 'leftarrow'
                    obj.previousChannel();
                case {'uparrow','downarrow'}
                    obj.toggleComposite();
            end

            fprintf('%s\n',strjoin([evt.Modifier,{evt.Character}],'|'))
        end

        function onEnter(obj,~,~)
            obj.BottomLabel.Visible = "on";
            % no-op to tools by default
        end

        function onLeave(obj,~,~)
            % hide label
            obj.BottomLabel.Visible = "off";
            % reset pointer to arrow
            if isvalid(obj.ParentFig)
                obj.ParentFig.Pointer = 'arrow';
            end
        end

    end

    %% Internal behaviors
    methods (Access=private)

        % executes on mouse move after Distractors/Interceptors
        function onMouseMove(obj)
            obj.updateBottomLabelText();
            obj.updatePointer();
        end

    end

    %% Tool event routing
    methods

        function tf = routeToDistractors(obj,evt,tgt,eventType)
        % eventType: 'Move' | 'Down' | 'Up' | 'Scroll

            % cell array of Distractors for this eventType, sorted by Priority
            distractors = obj.getPriorityDistractors(eventType);

            % whether to bypass the active Interceptor after Distraction event
            tf = false;

            % no Distractors for this eventType, return early
            if isempty(distractors), return; end

            for i = 1:numel(distractors)
                tf = distractors{i}.(['onDistract',eventType])(evt,tgt) | tf;
            end

        end

    end

    %% Tool management (register/unregister, load/unload, install/uninstall)
    methods

        % register a tool (add it to the installed tool registry) - tools call this themselves
        function registerTool(obj, tool)
            if ~isvalid(tool)
                warning('Failed to register tool. Invalid handle.')
                return
            end

            % add toolbar button
            obj.addToolbarButton(tool);
            % add to installed tools struct
            obj.Tools.(tool.Name) = tool;

            % add to registry
            obj.ToolRegistry(char(tool.Name)) = tool;
        end

        % remove tool from installed tool registry - it remains loaded
        function unregisterTool(obj, tool)
            % if tool is not registered
            if ~obj.ToolRegistry.isKey(char(tool.Name))
                warning('Failed to unregister tool. "%s" tool is not currently registered.',tool.Name)
                return
            end

            % remove toolbar button
            obj.removeToolbarButton(tool);
            % remove from installed tools struct
            obj.Tools = rmfield(obj.Tools,tool.Name);

            % remove from registry
            obj.ToolRegistry.remove(char(tool.Name));
        end

        % load all tools in widgets.tools
        function loadAllTools(obj)
            % cell array of tool names
            toolNames = obj.getToolNames();
            % return if no tools found
            if isempty(toolNames), return; end
            % load each tool
            for i = 1:numel(toolNames), obj.loadTool(toolNames{i}); end
        end

        % unload all currently loaded tools
        function unloadAllTools(obj)
            % cell array of tool names
            toolNames = obj.ToolList.keys;
            % return if no tools are currently loaded
            if isempty(toolNames), return; end
            % unload each tool
            for i = 1:numel(toolNames), obj.unloadTool(toolNames{i}); end
        end

        % load tools specified by toolNames (cell array of char vectors)
        function loadTools(obj,toolNames)
            % return if no tools found
            if isempty(toolNames), return; end
            % load each tool
            for i = 1:numel(toolNames), obj.loadTool(toolNames{i}); end
        end

        % load tool specified by name
        function loadTool(obj, name)
            if obj.ToolList.isKey(char(name))
                warning('Failed to load tool. "%s" tool already loaded.',name)
                return
            end
            % add to loaded Tools registry
            obj.ToolList(char(name)) = widgets.tools.(char(name))(obj);
        end

        % unload tool specified by name
        function unloadTool(obj, name)
            if ~obj.ToolList.isKey(char(name))
                warning('Failed to unload tool. "%s" tool is not loaded.',name)
                return
            end
            % get from loaded tools registry
            tool = obj.getLoadedTool(name);
            % if tool is installed, uninstall before unloading
            if tool.Installed, obj.uninstallTool(tool.Name); end

            % delete the tool (it will perform teardown tasks)
            delete(tool)
            % remove from loaded Tools registry
            obj.ToolList.remove(char(name));
        end

        % install tools specified by toolNames (cell array of char vectors)
        function installTools(obj,toolNames)
            % return if empty
            if isempty(toolNames), return; end
            % install each tool
            for i = 1:numel(toolNames), obj.installTool(toolNames{i}); end
        end

        % install tool specified by name
        function installTool(obj,name)
            thisTool = obj.getLoadedTool(name);
            % if no tool with this name found in tool list
            if isempty(thisTool)
                warning('Failed to install tool. "%s" tool is not loaded.',name)
                return
            end
            % check if tool is already registered
            if obj.ToolRegistry.isKey(char(thisTool.Name))
                warning('Failed to install tool. "%s" tool is already installed.',name)
                return
            end
            % call the tool's install() method, it will register itself and perform startup tasks
            thisTool.install();
        end

        % uninstall tool specified by name
        function uninstallTool(obj,name)
            thisTool = obj.getLoadedTool(name);
            % if no tool with this name found in tool list
            if isempty(thisTool)
                warning('Failed to uninstall tool. "%s" tool is not loaded.',name)
                return
            end
            % if no tool with this name is currently installed
            if ~obj.ToolRegistry.isKey(char(thisTool.Name))
                warning('Failed to uninstall tool. "%s" tool is already uninstalled.',name)
                return
            end
            % call the tool's uninstall() method, it will remove itself from the registry and perform cleanup tasks
            thisTool.uninstall();
        end

    end

    %% Toolbar management (add, remove, reorder toolbar buttons)
    methods

        % add a toolbar button for the tool (tool calls this on install)
        function addToolbarButton(obj, tool)
            obj.ToolbarButtons.(tool.Name) = axtoolbarbtn(obj.mainAxes.Toolbar,'state',...
                'Tooltip',tool.Tooltip,...
                'Icon',tool.Icon,...
                'ValueChangedFcn',@(btn,~) onToolToggle(obj, btn.Value, tool.Name));
            % reset the toolbar (it will disappear on hover otherwise)
            obj.mainAxes.Toolbar.reset;
        end

        % add a toolbar button for the tool (tool calls this on uninstall)
        function removeToolbarButton(obj, tool)
            % tool name not found in obj.ToolbarButtons struct, exit early
            if ~isfield(obj.ToolbarButtons,tool.Name), return; end
            % toolbar button linked to this tool
            tbButton = obj.ToolbarButtons.(tool.Name);
            % button is not valid, exit early
            if ~isvalid(tbButton), return; end
            % delete the toolbar button
            delete(tbButton)
            % delete the corresponding field in obj.ToolbarButtons struct
            obj.ToolbarButtons = rmfield(obj.ToolbarButtons,tool.Name);
            % reset the toolbar (it will disappear on hover otherwise)
            obj.mainAxes.Toolbar.reset;
        end

    end

    %% Toggle/query tool state
    methods

        % enable installed tool specified by name
        function enableTool(obj, name)
            t = obj.getInstalledTool(name); 
            if isempty(t), return; end
            t.enable();
        end

        % disable installed tool specified by name
        function disableTool(obj, name)
            t = obj.getInstalledTool(name);
            if isempty(t), return; end
            t.disable();
        end

        % query Enabled state of tool specified by name
        function tf = toolEnabled(obj, name)
            t = obj.getInstalledTool(name);
            tf = ~isempty(t) && isvalid(t) && t.Enabled;
        end

        % toggle Enabled state of tool specified by name (toolbar button ValueChangedFcn)
        function onToolToggle(obj,toolState,name)
            switch toolState
                case true
                    obj.enableTool(name);
                case false
                    obj.disableTool(name);
            end
        end

        % disable ActiveExclusiveTool if it exists
        function disableActiveExclusive(obj)
            % get the existing exclusive tool
            existingExclusive = obj.ActiveExclusiveTool;
            % exit if none found
            if isempty(existingExclusive), return; end
            % otherwise disable it
            obj.disableTool(existingExclusive.Name);
        end

    end

    %% Retrieve/sort tools
    methods

        % get installed tool specified by name
        function t = getInstalledTool(obj, name)
            t = [];
            if ~isempty(obj.ToolRegistry) && isKey(obj.ToolRegistry, char(name))
                t = obj.ToolRegistry(char(name));
            end
        end

        % get loaded tool specified by name
        function t = getLoadedTool(obj, name)
            t = [];
            if ~isempty(obj.ToolList) && isKey(obj.ToolList, char(name))
                t = obj.ToolList(char(name));
            end
        end

        % get the highest Priority Interceptor for the specified eventType
        function tool = getPriorityInterceptor(obj,eventType)
            % cell array of Installed tools
            toolsCell = obj.ToolRegistry.values;
            % no Installed tools, exit early
            if isempty(toolsCell), tool = []; return; end
            % get logical idx of Installed, Enabled tools that can Intercept the given eventType
            idx = cellfun(@(t) t.Enabled & t.(['Captures',eventType]) ,toolsCell,'UniformOutput',true);
            % no matching tools, exit early
            if ~any(idx), tool = []; return; end
            % sort the tools by priority (descending order)
            tools = obj.prioritySortToolsCell(toolsCell(idx));
            % return the first element (highest priority)
            tool = tools{1};
        end

        % get cell array of Distractors for the specified eventType, sorted by descending Priority
        function toolsCell = getPriorityDistractors(obj,eventType)
            % cell array of Installed tools
            toolsCell = obj.ToolRegistry.values;
            % no Installed tools, exit early
            if isempty(toolsCell), return; end
            % get logical idx of Installed tools that can Distract the given eventType
            idx = cellfun(@(t) t.(['Distracts',eventType]),toolsCell,'UniformOutput',true);
            % no matching tools, exit early
            if ~any(idx), toolsCell = {}; return; end
            % sort the tools by priority (descending order)
            toolsCell = obj.prioritySortToolsCell(toolsCell(idx));
        end

        % given a containers.Map of tools, return cell array of tools sorted by descending Priority
        function toolsCell = prioritySortTools(obj,toolsMap)
            % sort toolsMap.values by priority in descending order
            toolsCell = obj.prioritySortToolsCell(toolsMap.values);
        end

        % given a cell array of tools, return the same cell array sorted by descending Priority
        function toolsCell = prioritySortToolsCell(~,toolsCell)
            % empty cell, exit early
            if isempty(toolsCell), return; end
            % array of (sorted) Priority values for each tool
            priority = cellfun(@(t) t.Priority,toolsCell,'UniformOutput',true);
            [~,sortIdx] = sort(priority,'descend');
            % sort using the idxs returned by sort
            toolsCell = toolsCell(sortIdx);
        end

    end

    %% User-facing tool management (Set/Get to change loaded/installed tools)
    methods

        % get loaded tool names
        function ToolBox = get.ToolBox(obj)
            ToolBox = obj.ToolList.keys;
        end

        % set loaded tools
        function set.ToolBox(obj,newToolBox)
            % cell array of currently loaded tool names
            oldToolBox = obj.ToolBox;
            % tools in newToolBox that are not in oldToolBox (need to load them)
            toolsToAdd = setdiff(newToolBox,oldToolBox,'stable');
            % tools in oldToolBox that are not in newToolBox (need to unload them)
            toolsToRemove = setdiff(oldToolBox,newToolBox,'stable');
            % load all new tools in newToolBox
            if ~isempty(toolsToAdd)
                for i = 1:numel(toolsToAdd)
                    % load the tool
                    obj.loadTool(toolsToAdd{i});
                end
            end
            % unload any loaded tools not in newToolBox
            if ~isempty(toolsToRemove)
                for i = 1:numel(toolsToRemove)
                    % unload the tool
                    obj.unloadTool(toolsToRemove{i});
                end
            end
        end

        % get installed tool names
        function ToolBelt = get.ToolBelt(obj)
            ToolBelt = obj.ToolRegistry.keys;
        end

        % set installed tools (load first if necessary)
        function set.ToolBelt(obj,newToolBelt)
            % cell array of currently installed tool names
            oldToolBelt = obj.ToolBelt;
            % tools in newToolBelt that are not in oldToolBelt (need to install them)
            toolsToAdd = setdiff(newToolBelt,oldToolBelt,'stable');
            % tools in oldToolBelt that are not in newToolBelt (need to uninstall them)
            toolsToRemove = setdiff(oldToolBelt,newToolBelt,'stable');
            % install all uninstalled tools in newToolBelt (load first if necessary)
            if ~isempty(toolsToAdd)
                for i = 1:numel(toolsToAdd)
                    % tool is not already loaded, load it before installing
                    if ~obj.ToolList.isKey(toolsToAdd{i})
                        obj.loadTool(toolsToAdd{i});
                    end
                    % install the tool
                    obj.installTool(toolsToAdd{i});
                end
            end
            % uninstall any installed tools not in newToolBelt (do not unload)
            if ~isempty(toolsToRemove)
                for i = 1:numel(toolsToRemove)
                    % uninstall the tool
                    obj.uninstallTool(toolsToRemove{i});
                end
            end
        end

    end

    %% Active CData/CLim management
    methods

        % --- CLim ---
        function v = get.CLim(obj)
            v = obj.CLimStore{obj.ChannelIdx};
        end

        function set.CLim(obj,val)
            % update private backing
            obj.CLimStore{obj.ChannelIdx} = double(val);
            % setting the CLim switches CLim mode to manual
            obj.CLimMode_ = 'manual';
            if obj.ShowComposite
                obj.CData_ = obj.getComposite(); % update CData backing with composite
            end
            % update the CData of the Image object
            obj.updateImageCData();
            % update the Colorbar
            obj.updateColorbar();
        end

        % --- CData ---
        function v = get.CData(obj)
            v = obj.CData_;
        end

        % user-facing setter, resets CDataStore
        function set.CData(obj,cdata)
            % empty -> set placeholder
            if isempty(cdata)
                cdata = widgets.ImageAxes.placeholderImage();
            end
            % set CDataStore and multi-channel management props
            obj.setChannels(cdata);
            % sync CData to active channel
            obj.syncCDataToActiveChannel();
        end

        % --- CLimMode ---
        function v = get.CLimMode(obj)
            v = obj.CLimMode_;
        end

        function set.CLimMode(obj,val)
            % update private backing
            obj.CLimMode_ = val;
            % if set to 'auto'
            if strcmp(obj.CLimMode_,'auto')
                % update CLim for each channel
                obj.updateCLimStore();
            end
            % update the CData on the actual image object
            obj.updateImageCData();
            % update the Colorbar
            obj.updateColorbar();
        end

        % --- CDataSize ---
        function v = get.CDataSize(obj)
            if obj.ShowComposite
                v = size(obj.CData_);
            else
                v = obj.CDataSizeStore{obj.ChannelIdx};
            end
        end

        % --- CDataType ---
        function v = get.CDataType(obj)
            if obj.ShowComposite
                v = 'rgb';
            else
                v = obj.CDataTypeStore{obj.ChannelIdx};
            end
        end

        % --- CDataClass ---
        function v = get.CDataClass(obj)
            if obj.ShowComposite
                v = class(obj.CData_);
            else
                v = obj.CDataClassStore{obj.ChannelIdx};
            end
        end

        % --- DisplayCData ---
        function v = get.DisplayCData(obj)
            switch obj.CDataType
                case 'grayscale'
                    v = utils.rescaleLinear(obj.CData,obj.CLim);
                case 'rgb'
                    v = obj.CData_;
            end
        end

    end

    %% Multi-channel CData management (internal)
    methods (Access=private)

        function setChannels(obj,channels)
            % not cell input -> make cell
            if ~iscell(channels), channels = {channels}; end

            obj.CDataStore = channels;
            obj.nChannels = numel(obj.CDataStore);
            obj.ChannelIdx_ = 1;
            obj.MultiChannel = obj.nChannels > 1;

            % determine CDataType, CDataClass, and CDataSize for each channel
            for c = 1:obj.nChannels

                cdata = obj.CDataStore{c};

                % image dimensions
                sz = size(cdata);

                % set CDataType based on number of dimensions
                switch numel(sz)
                    case 2
                        cdataType = 'grayscale';
                    case 3
                        if sz(3)==3
                            cdataType = 'rgb';
                        else
                            error('ImageAxes:InvalidCDataSize','CData must be MxN (grayscale) or MxNx3 (truecolor)');
                        end
                    otherwise
                        error('ImageAxes:InvalidCDataDimensions','CData must have either 2 or 3 dimensions');
                end

                obj.CDataTypeStore{c} = cdataType;
                obj.CDataClassStore{c} = class(cdata);
                obj.CDataSizeStore{c} = sz;
                obj.CLimStore{c} = [0 1]; % default
            end

            % update CLimStore -> determine CLim for each channel
            obj.updateCLimStore();
            % update MultiChannelType
            obj.updateMultiChannelType();
            % update colormaps
            obj.updateCDataMapStore();
        end

        function updateCLimStore(obj)
        % get auto CLim for each element of CDataStore
            for c = 1:obj.nChannels
                cdata = obj.CDataStore{c};
                switch obj.CDataTypeStore{c}
                    case 'grayscale'
                        clim = double([min(min(cdata)) max(max(cdata))]);
                    case 'rgb'
                        clim = [0 1];
                end
                if clim(1)==clim(2)
                    obj.CLimStore{c} = getrangefromclass(cdata);
                else
                    obj.CLimStore{c} = clim;
                end
            end
        end

        function updateMultiChannelType(obj)
            if ~obj.MultiChannel, obj.MultiChannelType = 'none';
            elseif all(ismember(obj.CDataTypeStore,'grayscale')), obj.MultiChannelType = 'grayscale';
            elseif all(ismember(obj.CDataTypeStore,'rgb')), obj.MultiChannelType = 'rgb';
            else, obj.MultiChannelType = 'mixed'; 
            end
        end

        function syncCDataToActiveChannel(obj)
            if obj.ShowComposite
                % set CData from composite of all channels
                obj.setCData(obj.getComposite());
            else
                % set CData from the active channel
                obj.setCData(obj.CDataStore{obj.ChannelIdx});
            end
        end

        % sets active CData and emits CDataChanged
        function setCData(obj,cdata)
            % create event data payload before setting new CData and emitting CDataChanged event
            evtData = widgets.events.CDataChangedEventData(obj.CData_,cdata);
            % update private backing
            obj.CData_ = cdata;
            % refresh view
            obj.refreshView();
            % emit event, send payload
            notify(obj,'CDataChanged',evtData);
        end

        function I = getComposite(obj)

            switch obj.MultiChannelType
                case 'grayscale'
                    clims = cell2mat(obj.CLimStore');
        
                    switch obj.ChannelColorMode
                        case 'colors'
                            clrs = cellfun(@(C) utils.getColor(C),obj.ChannelColors,'UniformOutput',false);
                            colors = cell2mat(clrs');
                            I = utils.mergeChannelsRGB_add(obj.CDataStore,clims,colors(1:obj.nChannels,:));
                        case 'luts'
                            I = utils.mergeChannelsRGB_LUT(obj.CDataStore,clims,obj.CDataMapStore);
                    end
                case 'rgb'
                    I = utils.mergeRGBImages(obj.CDataStore,"Method","additive");
            end
        end

        function updateCDataMapStore(obj)
            switch obj.ChannelColorMode
                case 'colors'
                    for c = 1:obj.nChannels
                        obj.CDataMapStore{c} = utils.colorGradient([0 0 0],utils.getColor(obj.ChannelColors{c}),256);
                    end
                case 'luts'
                    obj.CDataMapStore = obj.ChannelColormaps;
            end
        end

    end

    methods

         % --- channel switching ---
        function nextChannel(obj)
            obj.ChannelIdx = utils.wrapStep(obj.ChannelIdx,1,1,obj.nChannels);
        end

        function previousChannel(obj)
            obj.ChannelIdx = utils.wrapStep(obj.ChannelIdx,-1,1,obj.nChannels);
        end       

        % --- ChannelIdx ---
        function v = get.ChannelIdx(obj)
            v = obj.ChannelIdx_;
        end

        function set.ChannelIdx(obj,val)
            % update private backing, clip ChannelIdx to [1 nChannels]
            obj.ChannelIdx_ = clip(val,1,obj.nChannels);
            % sync to active channel
            obj.syncCDataToActiveChannel();
        end

        % --- ChannelColors ---
        function val = get.ChannelColors(obj)
            val = obj.ChannelColors_;

            if numel(val)==obj.nChannels
                return
            end

            if numel(val)>obj.nChannels % too many colors
                val = val(1:obj.nChannels);
            elseif numel(val)<obj.nChannels % too few colors
                % get available colors not already in val
                avail = setdiff(widgets.ImageAxes.getColorNames,val);
                % number of additional colors we need
                nNeeded = obj.nChannels-numel(val);
                % add the number we need
                val = [val,avail(1:nNeeded)];
            end
            % update private backing
            obj.ChannelColors_ = val;
        end

        function set.ChannelColors(obj,val)
            % update private backing
            obj.ChannelColors_ = val;
            % update map store
            obj.updateCDataMapStore();
            % sync to active channel
            obj.syncCDataToActiveChannel();
        end

        % --- ChannelColormaps ---
        function val = get.ChannelColormaps(obj)
            val = obj.ChannelColormaps_;

            if numel(val)==obj.nChannels
                return
            end

            if numel(val)>obj.nChannels % too many colors
                val = val(1:obj.nChannels);
            elseif numel(val)<obj.nChannels % too few colors
                % number of additional maps we need
                nNeeded = obj.nChannels-numel(val);
                % add the number we need
                val = [val,repmat({gray},1,nNeeded)];
            end
            % update private backing
            obj.ChannelColormaps_ = val;
        end

        function set.ChannelColormaps(obj,val)
            % update private backing
            obj.ChannelColormaps_ = val;
            % update map store
            obj.updateCDataMapStore();
            % sync to active channel
            obj.syncCDataToActiveChannel();
        end

        % --- Colormap ---
        function v = get.Colormap(obj)
            v = obj.CDataMapStore{obj.ChannelIdx};
        end

        function set.Colormap(obj,val)
            % update private backing
            obj.ChannelColormaps_{obj.ChannelIdx} = double(val);
            % setting the Colormap switches ChannelColorMode mode to 'luts'
            obj.ChannelColorMode_ = 'luts';
            % update map store
            obj.updateCDataMapStore();
            % update the colormap on the actual axes object
            obj.updateAxesColormap();
        end

        % --- ChannelColorMode ---
        function v = get.ChannelColorMode(obj)
            v = obj.ChannelColorMode_;
        end

        function set.ChannelColorMode(obj,val)
            % update private backing
            obj.ChannelColorMode_ = val;
            % update colormap store
            obj.updateCDataMapStore();
            % sync
            obj.syncCDataToActiveChannel();
        end

        % --- ShowComposite ---
        function v = get.ShowComposite(obj)
            v = obj.ShowComposite_;
        end

        function set.ShowComposite(obj,val)
            % update backing
            obj.ShowComposite_ = val && obj.CanMerge;
            % sync
            obj.syncCDataToActiveChannel();
        end

        % toggle state on/off
        function toggleComposite(obj)
            obj.ShowComposite = ~obj.ShowComposite_;
        end

        % --- CanMerge ---
        function tf = get.CanMerge(obj)
            switch obj.MultiChannelType
                case {'grayscale','rgb'}
                    % true only if all channels have matching sizes and types
                    tf = isequal(obj.CDataSizeStore{:}) && isequal(obj.CDataClassStore{:});
                otherwise
                    tf = false;
            end
        end

        % --- ChannelCLim ---
        function setCLim(obj,clim,idx)
            arguments
                obj (1,1) widgets.ImageAxes
                clim (1,2) double
                idx (:,1) = []
            end

            % idx empty -> use active channel
            if isempty(idx)
                idx = obj.ChannelIdx;
            end

            if idx < 1 || idx > obj.nChannels
                error('ImageAxes:InvalidChannelIndex','Index %i does not refer to an existing channel',idx)
            end

            % update CLimStore
            obj.CLimStore{idx} = clim;
            % setting the CLim switches CLim mode to manual
            obj.CLimMode_ = 'manual';
            if obj.ShowComposite
                obj.CData_ = obj.getComposite(); % update CData backing with composite
            end
            % update the CData on the actual image object (do not emit CDataChanged)
            obj.updateImageCData();
        end


    end

    %% Hidden entrypoint for debugging
    methods (Hidden)

        function DEBUG_(obj)

            debug


        end

    end


    %% Utils
    methods (Static, Access=private)

        %function y = clip(x,a,b), y = max(a, min(b, x)); end

        % check if the point, XY, is within limits, XLim and YLim
        function tf = isInLimits(XY,XLim,YLim)
            x = XY(1); y = XY(2);
            tf = x >= XLim(1) && x <= XLim(2) && y >= YLim(1) && y <= YLim(2);
        end

        % return a placeholder image for startup
        function I = placeholderImage()
            % all black truecolor array
            I = zeros([256,256,3]);
        end

        % get colorbar ticks and labels based on CData class
        function [ticks,labels] = getColorbarTickLabels(valClass,clim,N)
            arguments
                valClass (1,:) char {mustBeMember(valClass,{'logical','double','single','uint16','uint8'})}
                clim (1,2) double
                N (:,1) = []
            end
        
            if isempty(N)
                if strcmp(valClass,'logical'); N = 2; else, N = 11; end
            end
        
            ticks = linspace(0,1,N);

            switch valClass
                case 'logical'
                    labels = arrayfun(@(v) sprintf('%i',v),ticks,'UniformOutput',false);
                case {'double','single'}
                    labels = arrayfun(@(v) sprintf('%.2f',v),linspace(clim(1),clim(2),N),'UniformOutput',false);
                case {'uint16','uint8'}
                    labels = arrayfun(@(v) sprintf('%i',v),round(linspace(clim(1),clim(2),N)),'UniformOutput',false);
            end
        end

    end

    methods (Static)

        % return names of all classes in widgets.tools
        function names = getToolClassNames()
            % get list of tool class names in widgets.tools using matlab.metadata.Namespace

            % string array
            % names = string({matlab.metadata.Namespace.fromName("widgets.tools").ClassList.Name})';

            % cell array of char vectors
            names = {matlab.metadata.Namespace.fromName("widgets.tools").ClassList.Name}';
        end

        % return names of all tool classes (just the last part)
        function names = getToolNames()

            classNames = widgets.ImageAxes.getToolClassNames();
            if numel(classNames)==0
                names = {};
                return
            else
                names = cell(1,numel(classNames));
                for i = 1:numel(classNames)
                    % split name with '.' delimeter
                    temp = strsplit(classNames{i},'.');
                    % tool name is after the final '.'
                    names(i) = temp(end);
                end
            end

        end

        % return names of allowed channel colors
        function names = getColorNames()
            names = {'cyan','magenta','yellow','red','green','blue'};
        end


        function ax = demo(name)
            arguments
                name (1,:) char {mustBeMember(name,{'default','multichannel','empty'})}
            end

            fig = uifigure("WindowStyle","alwaysontop",...
                "Position",[0 0 500 500],...
                "Visible","off");

            switch name
                case 'default'
                    ax = widgets.ImageAxes(fig,...
                        "ToolBelt",{'Zoom','Colorbar'},...
                        "Units","normalized",...
                        "Position",[0 0 1 1],...
                        "CData",imread("rice.png"),...
                        "CLim",[0 1],...
                        "Colormap",gray);
                case 'empty'
                    ax = widgets.ImageAxes(fig,...
                        "CData",[],...
                        "ToolBelt",{'Zoom','Colorbar'},...
                        "Units","normalized",...
                        "Position",[0 0 1 1],...
                        "CLim",[0 1]);
                case 'multichannel'
                    I1 = imread("rice.png");
                    I2 = imgaussfilt(I1);
                    cdata = {I1,I2};
                    ax = widgets.ImageAxes(fig,...
                        "CData",cdata,...
                        "ToolBelt",{'Zoom','Colorbar'},...
                        "Units","normalized",...
                        "Position",[0 0 1 1]);
            end

            movegui(fig,"center")

            fig.Visible = "on";

        end


    end

    %% Teardown
    methods

        function delete(obj)

            % remove listeners first
            if ~isempty(obj.L), delete(obj.L(isvalid(obj.L))); end
            % replace listener property with empty array of event.listener
            obj.L = event.listener.empty;


            % Unregister from hub (safe if figure already gone)
            try
                if ~isempty(obj.Hub) && isvalid(obj.Hub) && ~isnan(obj.RouterId)
                    obj.Hub.unregister(obj.RouterId);
                end
            catch
            end

            % unload (delete) all tools before deleting ImageAxes
            obj.unloadAllTools();

        end

    end

end
